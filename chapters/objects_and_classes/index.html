<!DOCTYPE html>
<html>
    <head>
        <title>Objects and Classes &mdash;  &mdash; </title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="http://lnwdr.github.io/php-introduction//components/foundation/css/foundation.min.css" rel="stylesheet" type="text/css" />
        <link href="http://lnwdr.github.io/php-introduction//components/highlightjs/styles/default.css" rel="stylesheet" type="text/css" />
        <link href="http://lnwdr.github.io/php-introduction//css/style.css" rel="stylesheet" type="text/css" />
        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <link rel="stylesheet" href="http://lnwdr.github.io/php-introduction//components/highlightjs/styles/github.css" />
                                    </head>
    <body>
        <div class="off-canvas-wrap" data-offcanvas>
            <div class="inner-wrap">
                <nav class="tab-bar">
                                    <section class="left-small">
                    <a class="left-off-canvas-toggle menu-icon" href="#"><span></span></a>
                </section>
                <section class="middle tab-bar-section">
                    <h1 class="title">Objects and Classes &mdash; </h1>
                </section>
                </nav>
                            <aside class="left-off-canvas-menu">
                <ul class="off-canvas-list">
</ul>
            </aside>

            <section class="main-section">
                <div class="row">
                    <div class="small-12 columns">
                        
<div class="row">
    <div class="small-4 columns text-left">
                    &nbsp;
            </div>
    <div class="small-4 columns text-center">
        <a href="http://lnwdr.github.io/php-introduction/">Index</a>
    </div>
    <div class="small-4 columns text-right">
                    &nbsp;
            </div>
</div>
                        <hr>
                    </div>
                </div>
                <div class="row">
                    <div class="small-12 columns">
                        <p>Modern PHP relies heavily on an object oriented style for structuring code. You'll find
this style in many libraries, frameworks and projects.</p>

<h2 id="what-is-an-object%3F">What is an object?</h2>

<p>In PHP <code>object</code> is one of the primitive types. It describes a value that is a bundle of data
and often also logic to work on that data.</p>

<p>An object lets you handle complex data structures as single values. Let's take an address for example.
It consists of several pieces of data:</p>

<ul>
<li>street</li>
<li>house number</li>
<li>city</li>
<li>postal code</li>
<li>country</li>
</ul>

<p>With the simpler primitive types, we can't store an address in a meaningful way so we need a
data structure to store an address in one single value to make sure, we keep track of every piece of data that belongs to it.</p>

<p>We also need to make sure that all addresses have the same structure, so that the parts of our application that handle addresses
can rely on. For example, the <code>postal_code</code> property of an address should always have the same name. If it's called <code>zip_code</code>
sometimes, it leads to inconsistency and potentially dangerous bugs.</p>

<p>To ensure a certain object structure, we use "class", a kind of blueprint for an object.</p>

<h2 id="classes">Classes</h2>

<pre><code class="php">&lt;?php

class Address
{
    public $street;
    public $house_number;
    public $city;
    public $postal_code;
    public $country;
}
</code></pre>

<p>This is a class definition. It introduces a class called <code>Address</code> and defines that all objects of this class have
the same five properties that we need to store an address.</p>

<p>Class names are written in a style called <code>StudlyCaps</code>: like <code>MyAwesomeClass</code>.</p>

<p>To make an address object from this class, we use the <code>new</code> operator:</p>

<pre><code class="php">$my_address = new Address();

var_dump($my_address);
</code></pre>

<p>Output:</p>

<pre><code>object(Address)#1 (5) {
  ["street"]=&gt;
  NULL
  ["house_number"]=&gt;
  NULL
  ["city"]=&gt;
  NULL
  ["postal_code"]=&gt;
  NULL
  ["country"]=&gt;
  NULL
}
</code></pre>

<p>The output tells us, it is an <code>object</code> of the class <code>Address</code> and it has 5 properties. The <code>#1</code>
is an internal ID that PHP assigns to every object to keep track of them.</p>

<h3 id="properties">Properties</h3>

<p>Now, every property of our object is <code>NULL</code> which is PHP's special value for "there's nothing here". To fill this address value with actual data, we could set every single property individually:</p>

<pre><code class="php">$my_address-&gt;street = "Main Street";
$my_address-&gt;house_number = 42;
$my_address-&gt;city = "Some Town";
$my_address-&gt;postal_code = "12345";
$my_address-&gt;country = "Far Far Away";
</code></pre>

<p>Output:</p>

<pre><code>object(Address)#1 (5) {
  ["street"]=&gt;
  string(11) "Main Street"
  ["house_number"]=&gt;
  int(42)
  ["city"]=&gt;
  string(9) "Some Town"
  ["postal_code"]=&gt;
  int(12345)
  ["country"]=&gt;
  string(7) "Far Far Away"
}
</code></pre>

<p>To access a property of an object, PHP uses the <code>-&gt;</code> operator, so <code>$my_address-&gt;street</code> means "the <code>street</code> property of the object in the variable <code>$my_address</code>".</p>

<h3 id="methods">Methods</h3>

<p>But setting every single property is tedious and not very easy to read. What if we could set it all at once? We'll need to add something to the class to do that.</p>

<pre><code class="php">&lt;?php

class Address
{
    public $street;
    public $house_number;
    public $city;
    public $postal_code;
    public $country;

    public function set($street, $house_number, $city, $postal_code, $country)
    {
        $this-&gt;street = $street;
        $this-&gt;house_number = $house_number;
        $this-&gt;city = $city;
        $this-&gt;postal_code = $postal_code;
        $this-&gt;country = $country;
    }
}

$my_address = new Address();

$my_address-&gt;set("Main Street", 42, "Some Town", 12345, "Far Far Away");

var_dump($my_address);
</code></pre>

<p>Output:</p>

<pre><code>object(Address)#1 (5) {
  ["street"]=&gt;
  string(11) "Main Street"
  ["house_number"]=&gt;
  int(42)
  ["city"]=&gt;
  string(9) "Some Town"
  ["postal_code"]=&gt;
  int(12345)
  ["country"]=&gt;
  string(7) "Far Far Away"
}
</code></pre>

<p>What we added, is a method. A function that is added to every object of our class. Inside a method, there's a special variable called <code>$this</code>, it refers to the object that the method was called on, in this case, the address object.</p>

<p>The <code>set</code> method just copies the values that it got via its arguments to the corresponding object properties.</p>

<h3 id="constructors">Constructors</h3>

<p>Making an address object without any data in the first place doesn't really make sense. It would be useful, and simpler to use, if we could set the data right when we create the object. There's a special method that does that, it's called a "constructor".</p>

<pre><code class="php">&lt;?php

class Address
{
    public $street;
    public $house_number;
    public $city;
    public $postal_code;
    public $country;

    public function __construct($street, $house_number, $city, $postal_code, $country)
    {
        $this-&gt;street = $street;
        $this-&gt;house_number = $house_number;
        $this-&gt;city = $city;
        $this-&gt;postal_code = $postal_code;
        $this-&gt;country = $country;
    }
}

$my_address = new Address("Main Street", 42, "Some Town", 12345, "Far Far Away");

var_dump($my_address);
</code></pre>

<p>The output will remain the same again. But this time, we didn't need to call an extra method to initialize our object. If a class has a method with the exact name <code>__construct</code>, it will be called when the object is created with the <code>new</code> operator. All arguments from the <code>new</code>call will also be passed to the constructor.</p>

<h2 id="visibility">Visibility</h2>

<p>Right now everything in our <code>Address</code> objects is accessible from the outside. A piece of code that doesn't behave well could do this:</p>

<pre><code class="php">function does_bad_things($address)
{
    $address-&gt;city = "Gotham City";

    return $address;
}
</code></pre>

<p>That function would modify an address after it has been created and filled with data. That doesn't make sense, a place doesn't change its address, streets don't magically move to a different city. People can move to a new address but the address itself can't change. We need to prevent the address from being changed after it's created. That's where the concept of "visibility" comes in. You might have wondered, what all the <code>public</code> keywords were for until now:</p>

<pre><code class="php">&lt;?php

class Address
{
    protected $street;
    protected $house_number;
    protected $city;
    protected $postal_code;
    protected $country;

    public function __construct($street, $house_number, $city, $postal_code, $country)
    {
        $this-&gt;street = $street;
        $this-&gt;house_number = $house_number;
        $this-&gt;city = $city;
        $this-&gt;postal_code = $postal_code;
        $this-&gt;country = $country;
    }
}
</code></pre>

<p>Now we changed the visibility of our address' properties to <code>protected</code>. The <code>do_bad_things</code> function from before will now fail:</p>

<pre><code>Fatal error: Cannot access protected property Address::$city in address.php on line 27
</code></pre>

<p>There are three levels of visibility in PHP: <code>public</code>, <code>protected</code> and <code>private</code>. For now, <code>public</code> means "is accessible from outside the object and <code>protected</code> means "is not accessible from the outside". We'll go into more detail on this and what <code>private</code> means when we talk about inheritance later.</p>

<h1 id="making-addresses-useful-again">Making Addresses useful again</h1>

<p>Now we have a nice immutable (not changeable) <code>Address</code> object but it can't do anything. We can't even read the data from it. Let's say we need these addresses in plain text form, maybe to send them in an email or to send them to the shipping company for our shop website.</p>

<p>We'll add a method that gives us the address data in a nicely formatted piece of text:</p>

<pre><code class="php">&lt;?php

class Address
{
    protected $street;
    protected $house_number;
    protected $city;
    protected $postal_code;
    protected $country;

    public function __construct($street, $house_number, $city, $postal_code, $country)
    {
        $this-&gt;street = $street;
        $this-&gt;house_number = $house_number;
        $this-&gt;city = $city;
        $this-&gt;postal_code = $postal_code;
        $this-&gt;country = $country;
    }

    public function getAsText()
    {
        return $this-&gt;street . PHP_EOL . $this-&gt;postal_code . ', ' . $this-&gt;city . PHP_EOL . $this-&gt;country;
    }
}
</code></pre>

<p>Now we can create an address and get the formatted text representation of it:</p>

<pre><code class="php">$my_address = new Address("Main Street", 42, "Some Town", 12345, "Far Far Away");

echo $my_address-&gt;getAsText() . PHP_EOL;
</code></pre>

<p>And the output will be:</p>

<pre><code>Main Street
12345, Some Town
Far Far Away
</code></pre>

<p>We can make this more convenient by using another "magic method". PHP classes have a bunch of special methods that all start with <code>__</code> and are executed automatically at certain points, <code>__construct()</code> is also one of them.</p>

<p>This time we will make a <code>__toString()</code> method from our <code>getAsText()</code>. It is called every time when our object is used as if it were a string, for example when we try <code>echo $my_address;</code>.</p>

<pre><code class="php">&lt;?php

class Address
{
    protected $street;
    protected $house_number;
    protected $city;
    protected $postal_code;
    protected $country;

    public function __construct($street, $house_number, $city, $postal_code, $country)
    {
        $this-&gt;street = $street;
        $this-&gt;house_number = $house_number;
        $this-&gt;city = $city;
        $this-&gt;postal_code = $postal_code;
        $this-&gt;country = $country;
    }

    public function __toString()
    {
        /*
         * Here, we break a long statement into multiple lines to make it more readable.
         * PHP will ignore the additional line breaks.
         */
        return
            $this-&gt;street . PHP_EOL .
            $this-&gt;postal_code . ', ' .
            $this-&gt;city . PHP_EOL .
            $this-&gt;country;
    }
}
</code></pre>

<p>Now we can just use the address as if it were already a string:</p>

<pre><code class="php">$my_address = new Address("Main Street", 42, "Some Town", 12345, "Far Far Away");

echo $my_address . PHP_EOL;
</code></pre>

<p>This will produce the same output as before.</p>

<hr />

<p>We now have a class for address objects that bundles data (the properties) and some logic (the constructor and toString method) and is protected from outside modification.</p>

<h2 id="static">Static</h2>

<p>While properties and methods usually belong to instances of classes, there are cases when a class itself needs to hold values in properties or offer methods. Those are called <code>static</code> properties and methods:</p>

<pre><code class="php">&lt;?php

class Foo
{
    static protected $some_value = "Bar!";

    static public function do_something()
    {
        echo static::$some_value . PHP_EOL;
    }
}

Foo::do_something();
</code></pre>

<p>We can call the <code>do_something()</code> method without making an instance of <code>Foo</code> at all. Instead of <code>-&gt;</code> we use <a href="http://php.net/manual/de/keyword.paamayim-nekudotayim.php"><code>::</code></a> to access a class' static properties and methods.</p>

<p>The visibility modifiers (<code>public</code>, <code>protected</code> and <code>private</code>) apply in the same way as for instances.</p>

<p>Static access is less common in PHP as it often introduces similar problems as global variables: a class with a static property is basically the same as a global variable and can make it very hard to keep track of where it is changed and where it is read from.</p>
                    </div>

                </div>
                <div class="row">
                    <div class="small-12 columns">
                        <hr>
                        
<div class="row">
    <div class="small-4 columns text-left">
                    &nbsp;
            </div>
    <div class="small-4 columns text-center">
        <a href="http://lnwdr.github.io/php-introduction/">Index</a>
    </div>
    <div class="small-4 columns text-right">
                    &nbsp;
            </div>
</div>
                    </div>
                </div>
            </section>

                <a class="exit-off-canvas"></a>
            </div>
        </div>

                <script src="http://lnwdr.github.io/php-introduction//components/jquery/jquery.min.js"></script>
        <script src="http://lnwdr.github.io/php-introduction//components/foundation/js/foundation.min.js"></script>
        <script>
            $(document).foundation();
        </script>
        <script src="http://lnwdr.github.io/php-introduction//components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
            </body>
</html>

