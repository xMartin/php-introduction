<!DOCTYPE html>
<html>
    <head>
        <title>A Real Application &mdash; PHP Introduction &mdash; A short introduction to PHP web development</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="/components/foundation/css/foundation.min.css" rel="stylesheet" type="text/css" />
        <link href="/components/highlightjs/styles/default.css" rel="stylesheet" type="text/css" />
        <link href="/css/style.css" rel="stylesheet" type="text/css" />
        <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
        <!--[if lt IE 9]>
            <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <link rel="stylesheet" href="/components/highlightjs/styles/github.css" />
                                    </head>
    <body>
        <div class="off-canvas-wrap" data-offcanvas>
            <div class="inner-wrap">
                <nav class="tab-bar">
                                    <section class="left-small">
                    <a class="left-off-canvas-toggle menu-icon" href="#"><span></span></a>
                </section>
                <section class="middle tab-bar-section">
                    <h1 class="title">A Real Application &mdash; PHP Introduction</h1>
                </section>
                </nav>
                            <aside class="left-off-canvas-menu">
                <ul class="off-canvas-list">
    <li>
        <a href="/chapters/intro/">Intro</a>
    </li>
    <li>
        <a href="/chapters/installation/">Installing PHP</a>
    </li>
    <li>
        <a href="/chapters/basic_syntax/">Basic Syntax</a>
    </li>
    <li>
        <a href="/chapters/a_web_application/">A Web Application</a>
    </li>
    <li>
        <a href="/chapters/objects_and_classes/">Objects and Classes</a>
    </li>
    <li>
        <a href="/chapters/a_real_application/">A Real Application</a>
    </li>
    <li>
        <a href="/chapters/builtin_functions_and_classes/">Built-in Functions and Classes</a>
    </li>
    <li>
        <a href="/chapters/arrays/">Arrays</a>
    </li>
    <li>
        <a href="/chapters/type_juggling/">Type Juggling and Comparisons</a>
    </li>
    <li>
        <a href="/chapters/more_on_functions/">More On Functions</a>
    </li>
    <li>
        <a href="/chapters/inheritance/">Inheritance</a>
    </li>
    <li>
        <a href="/chapters/namespaces_and_autoloading/">Namespaces and Autoloading</a>
    </li>
    <li>
        <a href="/chapters/all_of_it/">All Of It</a>
    </li>
</ul>
            </aside>

            <section class="main-section">
                <div class="row">
                    <div class="small-12 columns">
                                                                                                                                        
<div class="row">
    <div class="small-4 columns text-left">
                    <a href="/chapters/objects_and_classes/">Previous</a>
            </div>
    <div class="small-4 columns text-center">
        <a href="/">Index</a>
    </div>
    <div class="small-4 columns text-right">
                    <a href="/chapters/builtin_functions_and_classes/">Next</a>
            </div>
</div>
                        <hr>
                    </div>
                </div>
                <div class="row">
                    <div class="small-12 columns">
                        <p>This will be another exercise where we make a little web application. Again we'll use Silex as a framework.
So first, repeat the steps from <a href="/chapters/a_web_application/">chapter 03</a> to install Silex into a new directory.
Every project should have its own directory so things don't get messy.</p>

<p>Last time, our application just said "Hello World", now that's nice but not very useful. This time, we'll make an
event calendar, a website that shows events, ordered by date, each with a title, and description.
Each event will also have it's own page so we could send people a direct link to an event.</p>

<h2 id="data">Data</h2>

<p>First, we need something, to store our events in. To keep it simple, we'll use a text file for that with an easily
human-readable format called "YAML". It will look like this:</p>

<pre><code class="yml">---

- id: "mollis-ornare"
  title: "Mollis Ornare"
  description: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus."
  date: 2015-01-20 20:00
- id: "fusce-euismod-purus"
  title: "Fusce Euismod Purus"
  description: "Integer posuere erat a ante venenatis dapibus posuere velit aliquet. Etiam porta sem malesuada magna mollis euismod. Nullam id dolor id nibh ultricies vehicula ut id elit."
  date: 2015-02-01 19:00
- id: "bendum-odio"
  title: "Bendum odio"
  description: "Donec sed odio dui. Aenean lacinia bibendum nulla sed consectetur."
  date: 2015-02-17 21:00
</code></pre>

<p>If you wonder, what that gibberish text is, it's called <a href="http://en.wikipedia.org/wiki/Lorem_ipsum">"Lorem Ipsum"</a>. It's used as a placeholder because I didn't come up with something more creative.</p>

<p>Just save that into a file called <code>events.yml</code> in your project's  directory. Change the titles and descriptions, if you like.</p>

<p>Now, let's setup our Silex application. Just like last time, our starting point should look like this:</p>

<pre><code class="php">&lt;?php

require "vendor/autoload.php";

$app = new Silex\Application();

$app-&gt;get("/", function(){
    return "...";
});

$app-&gt;run();
</code></pre>

<h2 id="yaml">YAML</h2>

<p>We will need another library to read our YAML file. YAML support is not built into PHP itself. Let's install <code>symfony/yaml</code>, a very common library for dealing with YAML:</p>

<pre><code class="sh">./composer require symfony/yaml
</code></pre>

<p><code>composer require</code> tells Compose  to download one specific dependency and also to add it to our project's <code>composer.json</code> file.
If you already know what libraries you want to install, it's quicker than the interactive method we used before.</p>

<p>The things, composer installs for you are called "packages" and each of them has a unique name consisting of a vendor name and a package name, separated by a <code>/</code>,
like <code>silex/silex</code> or <code>symfony/yaml</code>. These packages are hosted on <a href="https://packagist.org">https://packagist.org</a>. There you can get information on each package or search for new packages.</p>

<p>The <code>symfony/yaml</code> package provides a namespace <code>Symfony\Component\Yaml</code>.
That's a bit too long to type it every time we want to use something from it. PHP has a way to make the contents of a namespace available to our code more conveniently:</p>

<pre><code class="php">use Symfony\Component\Yaml\Yaml;
</code></pre>

<p>This will put the <code>Yaml</code> class from the <code>Symfony\Component\Yaml</code> namespace directly into our current namespace so we can access it just by its name. This <code>use</code> statement should go right after the <code>require</code> in line 3. It's usually a good idea to put all <code>use</code> declarations at the top of your files so it's immediately obvious what dependencies a file needs.</p>

<p>We will need to read our events data at more than one place in our app so let's create a function the does that for us. That way, we avoid writing the same code twice.</p>

<pre><code class="php">function get_events() {
    $yaml_data = Yaml::parse(file_get_contents('events.yml'));
    $events = array_map(function($event) {
        $event['date'] = new DateTime($event['date']);
        return $event;
    }, $yaml_data);
    return $events;
}
</code></pre>

<p>Now let's see what we did here. <code>Yaml::parse()</code> is a so called "static method" of the class <code>Yaml</code>. Static methods can be called without making an instance of the class first. They are directly callable on the class itself. This method takes a string as an argument and tries to parse it as YAML. It then returns the result.</p>

<p>We get the YAML string from the <code>events.yml</code> file using <code>file_get_contents()</code>, it's a built-in function of PHP that reads a text file into a string. For a small file like ours, it's perfectly fine. For large files, it can be problematic because it loads the entire file into memory at once.</p>

<h2 id="date">Date</h2>

<p>Our events have a date but in our YAML files, the dates are just strings like "2015-01-20". We will later do some date/time operations with the so we need to convert them into actual dates. PHP has the <code>DateTime</code> class for this which represents a point in time and enables many time-related operations. We can construct one of those by using the string representation as an argument for the constructor:</p>

<pre><code class="php">$date = new DateTime('2015-01-20');
var_dump($date);
</code></pre>

<p>This will print:</p>

<pre><code>object(DateTime)#1 (3) {
  ["date"]=&gt;
  string(26) "2012-01-20 00:00:00.000000"
  ["timezone_type"]=&gt;
  int(3)
  ["timezone"]=&gt;
  string(13) "Europe/Berlin"
}
</code></pre>

<p>Note that the output contains a timezone. PHP always needs to know what timezone it should use for time-related operations. The default timezone is either configured for the entire PHP installation or it can be set by the application itself. We will set it ourselves. To make our app usable in different time zones, we put the timezone into a configuration file instead of hard-coding it into our PHP code. Let's call it <code>config.yml</code> and put this into it:</p>

<pre><code class="yml">---
timezone: "Europe/Berlin"
date_format: "d.m.Y"
time_format: "H:i"
</code></pre>

<p>The other two entries, beside the timezone, will become important soon.</p>

<p>To actually use this configuration, we need to parse this YAML file and put the config values somewhere where we can access it conveniently throughout our application. We'll use constants for that:</p>

<pre><code class="php">$config = Yaml::parse(file_get_contents('config.yml'));
define("TIMEZONE", $config['timezone']);
define("DATE_FORMAT", $config['date_format']);
define("TIME_FORMAT", $config['time_format']);
</code></pre>

<p>Now we have a constant for each config value and we can actually use them:</p>

<pre><code class="php">date_default_timezone_set(TIMEZONE);
</code></pre>

<p>PHP provides the <code>date_default_timezone_set()</code> function to set the timezone for your application. If your app does anything with date or time, you need to pay attention to this setting.</p>

<h2 id="mapping-arrays">Mapping Arrays</h2>

<p>In our <code>get_events()</code> function, we use another new thing: <code>array_map()</code>. After parsing our <code>events.yml</code> file, we get an array of our events and we need to convert the date string into a real date for each of them. <code>array_map()</code> iterates over an array, executes a custom function for each element and returns a new array with the return values of those function calls:</p>

<pre><code class="php"><br />$arr = [1,2,3,4];

$arr2 = array_map(function($item) {
    return $item * 2;
}, $arr);

var_dump($arr2);
</code></pre>

<p>This will print:</p>

<pre><code>array(4) {
  [0]=&gt;
  int(2)
  [1]=&gt;
  int(4)
  [2]=&gt;
  int(6)
  [3]=&gt;
  int(8)
}
</code></pre>

<p>Here, we doubled every element of the array. We used the same approach to make a new array of events with real dates.</p>

<h2 id="listing-events">Listing events</h2>

<p>OK, we did some initial setup, no we'll see, if that worked. Here's our first URL handler for the home page of our app:</p>

<pre><code class="php">$app-&gt;get('/', function() use ($app) {
    $events = get_events();

    usort($events, function($a, $b) {
        if ($a &lt; $b) {
            return -1;
        } else if ($a &gt; $b) {
            return 1;
        } else {
            return 0;
        }
    });

    return var_export($events, true);
});
</code></pre>

<p>We use our <code>get_events()</code> function to load the event data. After that, we need to make sure that they are sorted by date properly. For that, we use <code>usort()</code>, PHP's sorting function that accepts a custom comparison function. PHP doesn't know how to sort our custom event data by date, so we have to supply a function that tells it when an event is "less than" or "greater than" another event. The convention for that is, that our function returns <code>-1</code> if the first value is considered "smaller", <code>0</code> when they are equal and <code>1</code> when the first value is "less than" the second. This way, we can make any values sortable by our own criteria.</p>

<p>After sorting, we use <code>var_export()</code> to get a quick look at our data. <code>var_export()</code> is similar to <code>var_dump()</code> but it returns its output instead of printing it, if we set the second argument to <code>true</code>. We will use something much better for output in a moment but to check, if everything so far works, this is OK.</p>

<p>Start the app with <code>php -S localhost:8000 app.php</code> and open <code>http://localhost:8000/</code> in your browser. The output will be hard to read. Look at the source code of the page in your browser (Usually right-click->"show source", or something like that). Now you'll see something much like a <code>var_dump()</code> output.</p>

<h2 id="twig">Twig</h2>

<p>Displaying data in such a raw form is barely useful, except for debugging purposes. We'll need to generate some HTML to make a real web page. Instead of building the HTML output ourselves, we will use a very powerful templating language called <a href="http://twig.sensiolabs.org">Twig</a>.</p>

<p>To use Twig, we need to install it. It doesn't come bundled with Silex.</p>

<pre><code class="sh">./composer require twig/twig
</code></pre>

<p>This will download the Twig source code into your <code>vendor</code> directory and update the <code>composer.json</code> file accordingly so that <code>./composer install</code> will later also install Twig along with the other dependencies,</p>

<p>Make a new directory in your project called <code>views</code> and create a file called <code>event_list.twig</code> with the following content:</p>

<pre><code class="twig">
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;ul&gt;
            {% for event in events %}
            &lt;li&gt;
                &lt;a href="/{{event.id}}"&gt;
                    &lt;h2&gt;{{event.title}}&lt;/h2&gt;
                    &lt;p&gt;
                        {{event.date | date(date_format)}} -
                        {{event.date | date(time_format)}}
                    &lt;/p&gt;
                &lt;/a&gt;
            &lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>

<p>Now, our Silex application needs to know that we intend to use Twig:</p>

<pre><code class="php">$app = new Silex\Application();

$app-&gt;register(new Silex\Provider\TwigServiceProvider(), [
    'twig.path' =&gt; __DIR__ . '/views'
]);
</code></pre>

<p>Silex already has a component for using Twig, the <code>TwigServiceProvider</code>. When we instantiate it we just need to tell it where it can find our templates. It uses an array for its configuration and the <code>twig.path</code> value must contain a directory path where the templates are stored. We use the "magic constant" <code>__DIR__</code> to get the directory where <code>app.php</code> is and then append <code>/views</code> to get the full path to our views directory.</p>

<p>We can now replace the <code>var_export()</code> line in our URL handler with something else:</p>

<pre><code class="php">    //return var_export($events, true);

    return $app['twig']-&gt;render('event_list.twig', [
        'events' =&gt; $events,
        'date_format' =&gt; DATE_FORMAT,
        'time_format' =&gt; TIME_FORMAT
    ]);
</code></pre>

<p>Here's where the other two constants come into play. We pass their values into our template so we can use the configured date/time formats in Twig.</p>

<p>By registering the <code>TwigServiceProvider</code> we now have a Service for rendering Twig templates in <code>$app['twig']</code>. When we call its <code>render()</code> method with a template name and the data for that template, it returns the rendered HTML result.</p>

<p>Go ahead, refresh your browser window. You'll now see an HTML list of your events. Each of the list items is a link and when you click it ... it results in an error. Don't worry, that's expected. We just haven't implemented the detail page for individual events. Let's do that now:</p>

<p>Add this to your app.php file, after the first URL handler:</p>

<pre><code class="php">$app-&gt;get('{id}', function($id) use ($app) {
    $events = get_events();
    foreach($events as $e) {
        if ($e['id'] === $id) {
            $event = $e;
            break;
        }
    }
    if (!$event) {
        $app-&gt;abort(404, "Event '$id' does not exist.");
    }
    return $app['twig']-&gt;render('event_details.twig', [
        'event' =&gt; $event,
        'date_format' =&gt; DATE_FORMAT,
        'time_format' =&gt; TIME_FORMAT
    ]);
});
</code></pre>

<p>Also, make a new Twig template called <code>event_details.twig</code>:</p>

<pre><code class="twig">
&lt;!doctype html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;{{event.title}}&lt;/h1&gt;
        &lt;p&gt;{{event.date | date(date_format)}}
        &lt;p&gt;{{event.date | date(time_format)}}
        &lt;p&gt;{{event.description}}&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>

<p>This URL handler function is different from the first: It has a URL parameter <code>{id}</code>. That means, it will take that part of the URL and pass it into our function as an argument. And since all of our events have a unique ID, we can find the right one by comparing that parameter with their IDs:</p>

<pre><code class="php">foreach($events as $e) {
    if ($e['id'] === $id) {
        $event = $e;
        break;
    }
}
</code></pre>

<p>This is a <code>foreach</code> loop, it iterates over an array and puts the current element into the variable <code>$e</code> (or whatever else you name it) every time it runs. Inside the loop, we check, if the current event's ID is the one we got as a URL parameter. If they match, we put that event into the <code>$event</code>variable and stop the loop with <code>break;</code>.</p>

<p>There's the possibility that our loop didn't find any matching event. In that case the <code>$event</code> variable will be empty and we can react to that by telling Silex to produce an error page:</p>

<pre><code class="php">if (!$event) {
    $app-&gt;abort(404, "Event '$id' does not exist.");
}
</code></pre>

<p>This works, because PHP treats a value of <code>null</code> like <code>false</code> when we use it in a condition.</p>

<p>However, if we have found the correct event, we render the new Twig template with it:</p>

<pre><code class="php">return $app['twig']-&gt;render('event_details.twig', [
    'event' =&gt; $event,
    'date_format' =&gt; DATE_FORMAT,
    'time_format' =&gt; TIME_FORMAT
]);
</code></pre>

<p>Again, we also supply the two date/time format constants, just like before. Now, when you reload the page in your browser, the links will work!</p>

<hr />

<p>You now have a simple but already useful PHP application. Instead of writing HTML manually for this event calendar, you can edit the data in the <code>events.yml</code> file, which is far more convenient.</p>
                    </div>

                </div>
                <div class="row">
                    <div class="small-12 columns">
                        <hr>
                                                                                                                                        
<div class="row">
    <div class="small-4 columns text-left">
                    <a href="/chapters/objects_and_classes/">Previous</a>
            </div>
    <div class="small-4 columns text-center">
        <a href="/">Index</a>
    </div>
    <div class="small-4 columns text-right">
                    <a href="/chapters/builtin_functions_and_classes/">Next</a>
            </div>
</div>
                    </div>
                </div>
            </section>

                <a class="exit-off-canvas"></a>
            </div>
        </div>

                <script src="/components/jquery/jquery.min.js"></script>
        <script src="/components/foundation/js/foundation.min.js"></script>
        <script>
            $(document).foundation();
        </script>
        <script src="/components/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
            </body>
</html>

